#!/usr/bin/env python3
# SPDX-FileCopyrightText: Â© 2024 Shaun Wilson
# SPDX-License-Identifier: MIT
#
# A python script for decoding 'bindict' blobs extracted from python files.
##

import json
import os
import sys

if len(sys.argv) < 2:
    print('required path argument not provided, aborting.')
    exit(3)

__path:str = None
__force:bool = False

for arg in sys.argv[1:]:
    match arg:
        case '--force' | '-f':
            __force = True
        case _:
            if arg.startswith('-'):
                print('unrecognized command-line option `{arg}`, aborting.')
                exit(4)
            elif None != __path:
                print('unexpected positional argument `{arg}`, aborting.')
                exit(5)
            else:
                __path = arg

if not os.path.isdir(__path) and not os.path.isfile(__path):
    print(f'Provided path is invalid: {__path}')
    exit(1)

def decode_str(b:bytes, encodings = ['utf8', 'utf16']) -> str:
    for encoding in encodings:
        try:
            s:str = b.decode(encoding)
            # print(f'{encoding} -> {s}')
            return s
        except UnicodeDecodeError:
            pass
    return str(b)

def decoder(b:bytes) -> dict | None:
    try:
        rdi = 0
        d:dict = {}
        # read header
        count = int.from_bytes(b[rdi:rdi+8], 'little')
        rdi += 4
        # d['_h_count'] = count
        # read entry table
        tab:dict = {}
        # d['_h_tab'] = tab
        thead = 4 + ((count + 1) * 4)
        # d['_h_thead'] = thead
        tfoot = thead
        for i in range(count):
            f = int.from_bytes(b[rdi:rdi+4], 'little')
            t = int.from_bytes(b[rdi+4:rdi+8], 'little')
            rdi += 4
            k = decode_str(b[thead+f:thead+t])
            tfoot += (t - f)
            tab[i] = k
        # d['_h_tfoot'] = tfoot
        # d['_f_b1'] = b[tfoot:tfoot+5].hex()
        # d['_f_b2'] = b[tfoot+5:tfoot+10].hex()
        return d
    except Exception as ex:
        print(f'Decode Error: {ex}')
        return None

__restrict_to_filename:str = None
if os.path.isfile(__path):
    __path, __restrict_to_filename = os.path.split(__path)

for item in os.walk(__path):
    dirname = item[0]
    print(f'{dirname}\x1b[0J')
    filenames = item[2]
    if None != __restrict_to_filename:
        filenames = [ __restrict_to_filename ]
    i = 0
    for filename in filenames:
        i += 1
        filepath = os.path.join(dirname, filename)
        if filepath.endswith('.bindict'):
            print(f'[{i}/{len(filenames)}] {filename}\x1b[0J', end='\r')
            out_filepath = f'{filepath}.json'
            if not __force and os.path.isfile(out_filepath):
                continue
            file_content:str
            with open(filepath, 'rb') as in_file:
                file_content = in_file.read()
            result = decoder(file_content)
            if None != result:
                # print(f'{result["_f_b1"]} {result["_f_b2"]} << {filename}')
                j = json.dumps(result, indent='  ')
                # print(j)
                with open(out_filepath, 'wt') as out_file:
                    out_file.write(j)
    if None != __restrict_to_filename:
        break
